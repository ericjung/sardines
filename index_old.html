<script src="kaboom-0.2.0.js"></script>
<script type="module">

// make kaboom functions global
kaboom.global();

loadSprite("sardine", "sprites/sardine.png");
loadSprite("oceanBackground", "sprites/oceantile.png");
loadSprite("pinkFish", "sprites/pink-fish.png");
loadSprite("shark", "sprites/shark-1.png");
loadSprite("goldFish", "sprites/goldfish.png");
loadSprite("elliot", "sprites/elliot-tongue2.png");
loadSprite("seaWeed1", "sprites/seaweed-1.png");
loadSprite("crab", "sprites/crab.png");
loadSprite("seahorse", "sprites/seahorse.png");
loadSprite("scuba1", "sprites/scuba.png");
loadSprite("scuba2", "sprites/scuba2.png");
loadSprite("arrows", "sprites/arrows.png");
loadSprite("kracken", "sprites/kracken.png"); // thanks, max! http://pixelartmaker.com/art/c512d07f3150d9d

loadSound("scorePoint", "audio/bleep.wav");
loadSound("die", "audio/die.wav");
loadSound("backgroundMusicDuringGamePlay", "audio/mah-ma-mah-na.mp3");
loadSound("godMode", "audio/powerup1.wav");

init({
	fullscreen: true,
	scale: 2,
	width: window.innerWidth, height: window.innerHeight,
	clearColor: rgb(0, 0, 177)
});

let elliot, score, backgroundMusicDuringGamePlay;
const ELLIOT_SCALE = 0.1;
const livesSprites = [];
const shark = {
    name: "shark",
    max: 10,
    count: 0,
    orientation: null,
    speed: rand(80, 120),
    interval: 3000,
    timerId: null,
    scale: vec2(-1, 1),
    ydelta: {min: 10, max: 40},
    points: 10
},
sardine = {
    name: "sardine",
    max: 6,
    count: 0,
    orientation: null,
    speed: rand(30, 80),
    interval: 300,
    timerId: null,
    scale: vec2(0.5),
    ydelta: {min: 5, max: 30},
    points: 100
},
crab = {
    name: "crab",
    max: 1,
    count: 0,
    orientation: -1,
    speed: 15,
    interval: 1000,
    timerId: null,
    scale: vec2(0.1),
    ydelta: {min: 0, max: 0, direction: 1},
    pos: vec2(width()/2, height()-30),
    currentDelay: 0, 
    maxDelay: 5000, // delay until next crab appears
    points: 0
},
kracken =   {
    name: "kracken",
    max: 1,
    count: 0,
    orientation: null,
    speed: rand(30, 70),
    interval: 1000,
    timerId: null,
    scale: vec2(0.50),
    ydelta: {min: 0, max: 0},
    infoSpacing: {x: -10, y: 30},
    initalDelayBeforeRender: 5000,
    points: 50
  },
fishes = [
  {
    name: "pinkFish",
    max: 3,
    count: 0,
    orientation: null,
    speed: rand(30, 80),
    interval: 1000,
    timerId: null,
    scale: vec2(1),
    ydelta: {min: 10, max: 30},
    infoSpacing: {x: 0, y: 20},
    points: 1
  }, 
  {
    name: "goldFish",
    max: 2,
    count: 0,
    orientation: null,
    speed: rand(30, 80),
    interval: 1000,
    timerId: null,
    scale: vec2(0.05),
    ydelta: {min: 10, max: 50},
    infoSpacing: {x: 0, y: 20},
    points: 1
  },
  {
    name: "seahorse",
    max: 1,
    count: 0,
    orientation: -1,
    speed: rand(30, 80),
    interval: 1000,
    timerId: null,
    scale: vec2(0.05),
    ydelta: {min: 0, max: 0},
    infoSpacing: {x: 10, y: 30},
    points: 1
  },
  {
    name: "scuba1",
    max: 1,
    count: 0,
    orientation: null,
    speed: rand(30, 70),
    interval: 1000,
    timerId: null,
    scale: vec2(0.04),
    ydelta: {min: 0, max: 0},
    infoSpacing: {x: -10, y: 30},
    points: 1
  },
  {
    name: "scuba2",
    max: 1,
    count: 0,
    orientation: null,
    speed: rand(30, 70),
    interval: 1000,
    timerId: null,
    scale: vec2(0.14),
    ydelta: {min: 0, max: 0},
    infoSpacing: {x: -10, y: 30},
    points: 1
  },
],
fishSprites = [],
spritesToHideOnGameOver = [],
timersToClearOnGameOver = [];

scene("main", () => {

  playBackgroundMusic();
  
  /*add([
		sprite("oceanBackground"),
		scale(300,300),
		origin("topleft"),
        pos(0,0)
	]);*/

  for (let i = 0; i<9; i++) {
      add([
    		sprite("seaWeed1"),
    		scale(0.2),
    		origin("topleft"),
            pos(100*i, height()-95)
    	]);      
  }
  
  elliot = add([
		sprite("elliot"),
        scale(ELLIOT_SCALE, ELLIOT_SCALE),
		pos(width()/2, height()/2),
		rotate(0),
		origin("center"),
        {
        godMode: {
            enabled: false,
            timerId: null,
            seconds: 0,
            maxSeconds: 7
        },
        speed: 290,
        score: 0,
        lives: 3
    }
	]);

  keyDown("left", () => {
      if (paused()) {
          return;
      }
      if (elliot.pos.x > 0){
          elliot.move(vec2(-elliot.speed, 0));
      }
      else {
        elliot.pos.x = width();
      }
  });

  keyDown("right", () => {
      if (paused()) {
          return;
      }      
      if (elliot.pos.x < width()){
          elliot.move(vec2(elliot.speed, 0));
      }
      else {
        elliot.pos.x = 1;
      }      
  });

  keyDown("up", () => {
      if (paused()) {
          return;
      }      
      if (elliot.pos.y < 0){
          elliot.pos.y = 0;
      }
      else {
        elliot.pos.y -= 20;
      }     
  });

  keyDown("down", () => {
      if (paused()) {
          return;
      }      
      if (elliot.pos.y < height()){
          elliot.pos.y += 20;
      }
      else {
        elliot.pos.y = height()-20;
      }      
  });
  
    keyPress("space", () => {
        console.log("current pause value is " + paused());
        if (paused()) {
            pause(false);
            playBackgroundMusic();
        }
        else {
            pause(true);
            stopBackgroundMusic();
        }
        console.log("new pause value is " + paused());
    });
  
  // If in godmode, friend collisions result in destruction of friend
  // and some minimal points.
  function friendCollision(s) {
	  if (gameOver()) {
	      return;
	  }
	  if (elliot.godMode.enabled) {
        destroy(s);
        increaseScore(s.points);
	  }      
  }
  elliot.collides("pinkFish", s => friendCollision(s));
  elliot.collides("goldFish", s => friendCollision(s));
  elliot.collides("seahorse", s => friendCollision(s));
  elliot.collides("scuba1", s => friendCollision(s));
  elliot.collides("scuba2", s => friendCollision(s));

    // Yum
	elliot.collides("sardine", (s) => {
	  if (gameOver()) {
	      return;
	  }
      destroy(s);
      increaseScore(s.points);
	});

    // Super Elliot
	elliot.collides("crab", (s) => {
	  if (gameOver()) {
	      return;
	  }	    
	  console.log("*** god mode on!");
	  play("godMode");
	  elliot.godMode.enabled = true;
      destroy(s);
	  elliot.godMode.timerId = setInterval(() => {
	      if (elliot.godMode.seconds++ >= elliot.godMode.maxSeconds) {
	          clearInterval(elliot.godMode.timerId);
	          elliot.godMode.seconds = elliot.angle = 0;
	          //elliot.color = rgb(0, 0, 0);
	          elliot.godMode.enabled = false;
	          console.log("*** god mode off");
	      }
	  }, 1000);
	});

	elliot.collides("shark", (s) => {
	    destroy(s);
	    maybeGameOver(s);
	});
	
	elliot.collides("kracken", (s) => {
	    destroy(s);
	    maybeGameOver(s);
	});
	
	function maybeGameOver(enemy) {
	  if (gameOver()) {
	      return;
	  }
	  if (elliot.godMode.enabled) {
	      increaseScore(enemy.points);
	      return;
	  }
	  play("die");
	  elliot.lives--;
	  drawLives();
	  camShake(7);	  
	  if (elliot.lives > 0) {
	      return;
	  }
	  
	  stopBackgroundMusic();
	  
	  // stop fish from spawning
      for (const f in fishes) {
        // stop them spawning
        const fish = fishes[f];
        clearInterval(fish.timerId);
      }
      // Stop movement
      //for (const f in fishSprites) {
        //fishSprites[f].paused = true;
      //}
      for (const t in timersToClearOnGameOver) {
          clearInterval(timersToClearOnGameOver[t]);
      }
      // elliot.paused = true; // not working!
      for (const s in spritesToHideOnGameOver) {
          const tmp = spritesToHideOnGameOver[s];
          tmp.hidden = true;
      }        
    
        let x = (width() / 2)-200;
        let y = (height() / 2)-100;
        
        add([
    		text("game over", 24),
    		pos(x, y),
    	]);

      add([
        text("final score: " + elliot.score, 12),
        pos(x, y+=30),
      ]);
      
      add([
        text("press 'i' for instructions ", 12),
        pos(x, y+=60),
      ]);
      add([
        text("press 'space' to play again ", 12),
        pos(x, y+=15),
      ]);      
      
      keyPress("i", () => {
        go("instructions");
      });   
      
      keyPress("space", () => {
        resetGame();
        go("main");
      });
      
      function resetGame() {
          // reset game
          crab.count = sardine.count = shark.count = kracken.count = 0;
          for (const f in fishes) {
            fishes[f].count = 0;
          }
          spritesToHideOnGameOver.forEach(e => {
             destroy(e); 
          });
          spritesToHideOnGameOver.length = 0;
          fishSprites.forEach(e => {
             destroy(e); 
          });
          fishSprites.length = 0
          timersToClearOnGameOver.length = 0
      }
	}

  spritesToHideOnGameOver.push(
      add([
        text("Sardines!", 10),
        rgb(100,0,0),
        pos(10, 10)
    ]));
  spritesToHideOnGameOver.push(elliot);
  
  score = add([
      text("score: " + elliot.score, 8),
      pos(10, 25),
      rgb(0,255,0)
  ]);
  spritesToHideOnGameOver.push(score);

  function gameOver() {
      return elliot.lives <= 0;
  }
  // draw the lives
  function drawLives() {
      for (const i in livesSprites) {
          destroy(livesSprites[i]);
      }
      livesSprites.length = 0;
      for (let i=0; i<elliot.lives; i++) {
        livesSprites.push(add([sprite("elliot"), pos(width() - (i*30) - 10, 10), scale(ELLIOT_SCALE/2, ELLIOT_SCALE/2)]));
        console.log("there are " + livesSprites.length + " sprite lives");
      }
      if (elliot.lives > 0) {
        livesSprites.push(add([text("lives", 8), pos(width() - ((elliot.lives+1)*30), 15)]));
      }
  }
  
  drawLives();
  elliot.action(() => {
    // Animate elliot if he's in godmode
    // Wish we had transparency to fade him in/out
    if (elliot.godMode.enabled) {
        //elliot.scale = Math.sin(time()) * .2;
        elliot.angle += 1;
        //elliot.color = rgb(1, 0, 0);
    }    
  });
  
  // render the crab -- but not if godMode is already enabled!
  timersToClearOnGameOver.push(setInterval(() => {
    if (elliot.godMode.enabled) {
        return;
    }
    if (get("crab").length < crab.max && crab.currentDelay >= crab.maxDelay) {
        crab.orientation = choose([-1, 1]);
        crab.count++;
        fishSprites.push(addFishSprite(crab));
        crab.currentDelay = 0;
        console.log("crab added");
    }
    else {
        crab.currentDelay += crab.interval;
    }
  }, crab.interval));

  
  function renderSprite(guy) {
      if (guy.initalDelayBeforeRender) {
          // setTimeout() not setInterval() so it's only called once
          setTimeout(installTimer, guy.initalDelayBeforeRender);
      }
      else {
        installTimer();
      }
      function installTimer() {
        timersToClearOnGameOver.push(setInterval(() => {
            if (get(guy.name).length < guy.max) {
                guy.orientation = choose([-1, 1]);
                guy.count++;
                fishSprites.push(addFishSprite(guy));
                console.log(guy.name + " added");
            }
          }, guy.interval));          
      }
  }

  function addFishSprite(fish) {
    return add([
          sprite(fish.name),
          pos(fish.pos ? fish.pos :
            vec2(rand(-width() / 2, width() / 2), rand(height() / 2 + 21))),
          scale(fish.orientation*fish.scale.x, 1*fish.scale.y),
          fish.name, // tag
          {speed: fish.speed,
            orientation: fish.orientation,
            ydelta: rand(fish.ydelta.min, fish.ydelta.max) *
               // use the specified direction if one; otherwise random
              (fish.direction ? fish.direction : choose([-1,1])),
            points: fish.points
          }
    ]);      
  }    
  renderSprite(shark);
  renderSprite(sardine);
  renderSprite(kracken);
  for (const f in fishes) {
    renderSprite(fishes[f]);
  }
  
  ["shark", "pinkFish", "sardine", "goldFish", "crab", "seahorse", "scuba1", "scuba2", "kracken"].forEach(e => {
        action(e, p => botMove(p));
  });

  function botMove(p) {
	p.move(p.speed*p.orientation, p.ydelta);
    if (p.pos.x > width()) {
      p.pos.x = 1;
    }
    if (p.pos.x < 0) {
      p.pos.x = width();
    }
    if (p.pos.y > height()) {
      p.pos.y = 1;
    }
    if (p.pos.y < 0) {
      p.pos.y = height();
    }  
  }
  
  function increaseScore(points) {
      play("scorePoint");
      elliot.score += points;
      score.text = "score: " + elliot.score;      
  }
  randSeed(Date.now()); 
  console.log("ready");
});

function stopBackgroundMusic() {
    if (backgroundMusicDuringGamePlay) {
        backgroundMusicDuringGamePlay.stop();
        backgroundMusicDuringGamePlay = null; // .resume() does not work so force .play() to be called again when game restarts
    }
}

function playBackgroundMusic() {
    stopBackgroundMusic();
    backgroundMusicDuringGamePlay = play("backgroundMusicDuringGamePlay", {loop: true, volume: 0.5});  // .pause() and .resume() of music does not work very well      
}

scene("instructions", () => {
    let x = (width() / 2)-200, textX = x+80;
    let y = 10;
    add([text("Sardines!", 24), pos(x, y)]);
    add([text("Score points by eating sardines", 10), pos(x, y+=30)]);

    add([text("press 'space' to play", 10), pos(x, y+=15)]);
  
    add([sprite("elliot"), pos(x, y+=30), scale(ELLIOT_SCALE, ELLIOT_SCALE)])
    add([text("You", 10), pos(textX, y+=10)]);   
    
    add([sprite("sardine"), pos(x-10, y+=40), scale(sardine.scale.x, sardine.scale.y)])
    add([text("100 points", 10), pos(textX, y)]);
    add([sprite("crab"), pos(x, y+=15), scale(crab.scale.x, crab.scale.y)])
    add([text("god mode -- eat everything for points!", 10), pos(textX, y+=10)]);    

    add([sprite("shark"), pos(x+40, y+=25), scale(shark.scale.x, shark.scale.y)])
    add([sprite("kracken"), pos(x+50, y), scale(kracken.scale.x*0.7, kracken.scale.y*0.7)])    
    add([text("death!", 10), pos(textX, y+=5)]);   

    add([sprite("arrows"), pos(x-5, y+=25), scale(0.07, 0.07)]);
    add([text("move", 10), pos(textX, y+=15)]);

    // each of these need custom spacing
    fishes.forEach(fish => {
        add([sprite(fish.name), pos(x += fish.infoSpacing.x, y+=fish.infoSpacing.y), scale(fish.scale.x, fish.scale.y)]);   
        add([text("friend", 10), pos(textX, y+=7)]);
    });
    /*let i = 0;
    y+=20;
    x-=30;
    for (const f in fishes) {
        i++;
        const fish = fishes[f];
        add([sprite(fish.name), pos(x+=30, y+=5), scale(fish.scale.x, fish.scale.y)]);
    }
    add([text("friends", 10), pos(textX, y-(i*10))]);
    */
  keyPress("space", () => {
    go("main")
  });
});

start("instructions");
</script>